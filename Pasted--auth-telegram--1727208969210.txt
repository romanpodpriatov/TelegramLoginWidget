Проблема, с которой вы столкнулись, связана с тем, что маршрут /auth/telegram в вашем приложении не принимает HTTP-метод GET, который используется виджетом Telegram Login для передачи данных аутентификации. Это приводит к ошибке "Method Not Allowed" (405).

Давайте поэтапно разберёмся, как исправить эту проблему и правильно настроить интеграцию виджета Telegram Login в ваше приложение на Quart.

Шаг 1: Убедитесь, что маршрут /auth/telegram принимает метод GET

1.1. Проверьте auth.py
Убедитесь, что в вашем файле auth.py маршрут /auth/telegram определён с методом GET. Вот как должен выглядеть ваш auth.py:

python
Копировать код
# auth.py
from quart import Blueprint, render_template, redirect, url_for, request
from quart_auth import login_user, logout_user, login_required, current_user, AuthUser
from models import User
from sqlalchemy.future import select
from db import async_session
import hashlib
import hmac
import os
import logging

auth = Blueprint('auth', __name__)
logger = logging.getLogger(__name__)

@auth.route('/auth/telegram', methods=['GET'])
async def telegram_auth():
    params = request.args
    logger.info(f"Received Telegram auth params: {params}")
    auth_data = {
        'id': params.get('id'),
        'first_name': params.get('first_name'),
        'last_name': params.get('last_name'),
        'username': params.get('username'),
        'photo_url': params.get('photo_url'),
        'auth_date': params.get('auth_date'),
        'hash': params.get('hash')
    }

    # Валидация данных от Telegram
    if not validate_telegram_auth(auth_data):
        logger.warning("Invalid Telegram authentication")
        return await render_template('auth/login.html', error="Invalid Telegram authentication")

    user_id = auth_data['id']
    username = auth_data.get('username') or f"user_{user_id}"

    async with async_session() as session:
        result = await session.execute(select(User).where(User.id == user_id))
        user = result.scalar_one_or_none()
        if not user:
            # Создайте нового пользователя, если он не существует
            user = User(id=user_id, username=username, password_hash='')  # Пароль можно оставить пустым
            session.add(user)
            await session.commit()
        await login_user(AuthUser(id=user.id))
    
    return redirect(url_for('index'))

def validate_telegram_auth(auth_data):
    # Получите ваш токен бота
    bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
    if not bot_token:
        logger.error("TELEGRAM_BOT_TOKEN not set")
        return False

    # Получите секретный ключ
    secret_key = hashlib.sha256(bot_token.encode()).digest()

    # Отсортируйте данные по ключам
    sorted_data = sorted((k, v) for k, v in auth_data.items() if k != 'hash')

    # Создайте строку для хэширования
    data_check_string = "\n".join(f"{k}={v}" for k, v in sorted_data)

    # Вычислите хэш
    hash_digest = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()

    # Сравните вычисленный хэш с предоставленным
    return hmac.compare_digest(hash_digest, auth_data['hash'])
Пояснения:

methods=['GET']: Убедитесь, что маршрут /auth/telegram принимает метод GET, так как виджет Telegram Login отправляет данные через GET-запрос.
Логирование: Добавлены сообщения логов для упрощения отладки.
Валидация: Метод validate_telegram_auth проверяет подлинность данных, полученных от Telegram.